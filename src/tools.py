## Grepping functions from the vulnerability context of the file.
# Fetching the functions which have given line context/statement.
### Parsing CppCheck output:


import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px
import lizard
import subprocess as sub
from pylibsrcml import srcml
import os
import xml.etree.ElementTree as et
import sys
import csv
from io import BytesIO, StringIO

# from lxml import etree
import pandas as pd
import subprocess as sub
import sys

############################## Applying CppCheck tool ##############################
def fetch_location(err):
    """get locations of all the error list generated by CppCeck"""
    dt_loc = {"file": [], "line": [], "column": [], "info": []}
    for loc in err.findall("location"):
        for key, val in (loc.attrib).items():
            dt_loc[key].append(val)

    # avoid list for single valued items;
    # TODO check if it applies for all the projects
    for key in dt_loc.keys():
        if len(dt_loc[key]) == 1:
            dt_loc[key] = dt_loc[key][0]
    return dt_loc


def xml2df_cppcheck(file):
    """convert xml file of cppcheck to dataframe"""
    if os.path.isfile(file):
        xtree = et.fromstring(open(file).read())
        df = pd.DataFrame()

        for errors in xtree.findall(".//errors"):
            for err in errors.findall("error"):
                dt_err = err.attrib

                ## get location of the vulnerable line content
                dt_err.update(fetch_location(err))
                df = pd.concat([df, pd.DataFrame([dt_err])], ignore_index=True).drop(
                    columns=["file"], axis=1
                )

        return df.rename(columns={"file0": "file"})
    else:
        return None


def apply_cppcheck(file_or_dir, xmlfile="output.xml"):
    """find flaws in the file using CppCheck tool
    example commands:
    !cppcheck --template=gcc ../data/projects/contiki-2.4/apps/ 2> err.txt
    !cppcheck --template="{file}; {line}; {severity}; {message}; {code}"
    --template-location=" {file};{line}; {info};{code}\n" <path> 2> err.txt
    """
    cmd = ["cppcheck -a -f " + file_or_dir + " --xml 2> + " + xmlfile]
    process = sub.Popen(cmd, shell=True, stdout=sub.PIPE)
    output = process.stdout.read()
    # TODO: try not to create output.xml file instead use BytesIO.
    df = xml2df_cppcheck(xmlfile)
    df["line"] = df.line.astype(int)
    # df.to_csv('contiki24_cppcheck.csv')
    return df


############################## Applying FlawFinder tool ##############################
def apply_flawfinder(file_or_dir):
    """find flaws in the file using CppCheck tool"""
    if os.path.isfile(file_or_dir):
        cmd = "flawfinder --csv " + file_or_dir
    elif os.path.isdir(file_or_dir):
        cmd = "flawfinder --csv --inputs " + file_or_dir
    else:
        print("Please provide a valid project dir/file/link!")
    process = sub.Popen(
        cmd,
        shell=True,
        stdout=sub.PIPE,
    )
    output = process.stdout.read().decode("utf-8")
    df = pd.read_csv(StringIO(output))
    return df.reset_index(drop=True)


############################## Applying Rats tool ##############################
def xml2df_rats(xml):
    """convert xml file of rats tool to dataframe"""
    if isinstance(xml, str):
        xtree = et.fromstring(xml)
        df = pd.DataFrame()

        for err in xtree.findall("vulnerability"):
            dt = {
                "severity": err.find("severity").text,
                "type": err.find("type").text if err.find("type") != None else None,
                "message": err.find("message").text,
            }
            for loc in err.findall("file"):
                dt["file"] = loc.find("name").text

                for line in loc.findall("line"):
                    dt["line"] = line.text
                    df = pd.concat([df, pd.DataFrame([dt])], ignore_index=True)
            # df = df.drop(columns=["file"], axis=1)
        return df
    else:
        return None


def apply_rats(file_or_dir, xmlfile="output.xml"):
    """ The Rough Auditing Tool for Security is an open-source tool 
    developed by Secure Software Engineers
    https://security.web.cern.ch/recommendations/en/codetools/rats.shtml \
    For example: 
    `rats --quiet --xml -w 3 data/projects/contiki-2.4/apps/` 
    """
    # rats --quiet --xml -w 3 <dir_or_file>
    cmd = ["rats --quiet --xml -w 3 " + file_or_dir]
    process = sub.Popen(cmd, shell=True, stdout=sub.PIPE)
    output = process.stdout.read().decode("utf-8")
    df = xml2df_rats(output)

    # RATS tool does not produce results with CWE type.
    df["cwe"] = "unknown_vul"
    # df["line"] = df.line.astype(int)
    return df


if __name__ == "__main__":
    chk_dir = "data/projects/contiki-2.4/apps/"
    df_flaw = apply_cppcheck(chk_dir)
    print(df_flaw)
