## Grepping functions from the vulnerability context of the file.
# Fetching the functions which have given line context/statement.
### Parsing CppCheck output:


import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px
import lizard
import subprocess as sub
from pylibsrcml import srcml
import os
import xml.etree.ElementTree as et
import sys
import csv
from io import BytesIO, StringIO

# from lxml import etree
import pandas as pd
import numpy as np
import subprocess as sub
import sys

############################## Applying CppCheck tool ##############################
def fetch_location(err):
    """get locations of all the error list generated by CppCeck"""
    dt_loc = {"file": [], "line": [], "column": [], "info": []}
    for loc in err.findall("location"):
        for key, val in (loc.attrib).items():
            dt_loc[key].append(val)

    # avoid list for single valued items;
    # TODO check if it applies for all the projects
    for key in dt_loc.keys():
        if len(dt_loc[key]) == 1:
            dt_loc[key] = dt_loc[key][0]
    return dt_loc


def xml2df_cppcheck(file):
    """convert xml file of cppcheck to dataframe"""
    df = pd.DataFrame()
    if os.path.isfile(file):
        xtree = et.fromstring(open(file).read())
        for errors in xtree.findall(".//errors"):
            for err in errors.findall("error"):
                dt_err = err.attrib

                ## get location of the vulnerable line content
                dt_err.update(fetch_location(err))
                df = pd.concat([df, pd.DataFrame([dt_err])], ignore_index=True).drop(
                    columns=["file"], axis=1
                )
        df = df.rename(columns={"file0": "file"})
    return df.reset_index(drop=True)


def apply_cppcheck(file_or_dir, xmlfile="output.xml"):
    """find flaws in the file using CppCheck tool
    example commands:
    !cppcheck --template=gcc ../data/projects/contiki-2.4/apps/ 2> err.txt
    !cppcheck --template="{file}; {line}; {severity}; {message}; {code}"
    --template-location=" {file};{line}; {info};{code}\n" <path> 2> err.txt
    """
    cmd = ["cppcheck -a -f " + file_or_dir + " --xml 2> + " + xmlfile]
    process = sub.Popen(cmd, shell=True, stdout=sub.PIPE)
    output = process.stdout.read()
    # TODO: try not to create output.xml file instead use BytesIO.
    df = xml2df_cppcheck(xmlfile)
    if len(df):
        df["line"] = df.line.astype(int)
        df["tool"] = "CppCheck"
        # To make CWE column values uniform to FlawFinder output
        df["cwe"] = "CWE-" + df["cwe"]
    return df.reset_index(drop=True)


############################## Applying FlawFinder tool ##############################
def apply_flawfinder(file_or_dir):
    """find flaws in the file using CppCheck tool"""
    if os.path.isfile(file_or_dir):
        cmd = "flawfinder --csv " + file_or_dir
    elif os.path.isdir(file_or_dir):
        cmd = "flawfinder --csv --inputs " + file_or_dir
    else:
        print("Please provide a valid project dir/file/link!")
    process = sub.Popen(
        cmd,
        shell=True,
        stdout=sub.PIPE,
    )
    output = process.stdout.read().decode("utf-8")
    df = pd.read_csv(StringIO(output))
    if len(df):
        df["tool"] = "FlawFinder"
    return df.reset_index(drop=True)


############################## Applying Rats tool ##############################
def xml2df_rats(xml):
    """convert xml file of rats tool to dataframe"""
    df = pd.DataFrame()
    if isinstance(xml, str):
        xtree = et.fromstring(xml)
        for err in xtree.findall("vulnerability"):
            dt = {
                "severity": err.find("severity").text,
                "type": err.find("type").text if err.find("type") != None else None,
                "message": err.find("message").text,
            }
            for loc in err.findall("file"):
                dt["file"] = loc.find("name").text

                for line in loc.findall("line"):
                    dt["line"] = line.text
                    df = pd.concat([df, pd.DataFrame([dt])], ignore_index=True)
            # df = df.drop(columns=["file"], axis=1)
    return df.reset_index(drop=True)


def apply_rats(file_or_dir, xmlfile="output.xml"):
    """ The Rough Auditing Tool for Security is an open-source tool 
    developed by Secure Software Engineers
    https://security.web.cern.ch/recommendations/en/codetools/rats.shtml \
    For example: 
    `rats --quiet --xml -w 3 data/projects/contiki-2.4/apps/` 
    """
    # rats --quiet --xml -w 3 <dir_or_file>
    cmd = ["rats --quiet --xml -w 3 " + file_or_dir]
    process = sub.Popen(cmd, shell=True, stdout=sub.PIPE)
    output = process.stdout.read().decode("utf-8")
    df = xml2df_rats(output)

    if len(df):
        # RATS tool does not produce results with CWE type.
        df["cwe"] = "unknown_vul"
        df["line"] = df.line.astype(int)
        df["tool"] = "Rats"
    return df.reset_index(drop=True)


def concat(*args):
    """merge two columns of the dataframw with numpy vectorize method"""
    concat_str = ""
    try:
        strs = [str(arg) for arg in args if not pd.isnull(arg)]
        concat_str = ",".join(strs) if strs else np.nan
    except ValueError as e:
        print("Value Error: ", e)
        print(concat_str)
    return concat_str


def merge_tools_result(df_ff, df_cc, df_rat):
    """merge dataframe generated by FlawFinder and CppCheck tools"""
    common_cols = ["file", "line", "column", "cwe", "note"]
    unique_cols = ["context", "defaultlevel", "level", "helpuri"]
    filter_cols = [
        "toolversion",
        "fingerprint",
        "ruleid",
        "suggestion",
        "defaultlevel",
        "level",
    ]
    ## Adjusting columns generated by FlawFinder tool
    df_ff = df_ff.rename(columns=str.lower)  # lower case
    df_ff = df_ff.rename(columns={"cwes": "cwe", "warning": "msg"})

    ## Adjusting columns generated by CppCheck tool
    df_cc = df_cc.rename(columns={"info": "note", "id": "name"})

    ## Adjusting columns generated by CppCheck tool
    df_rat = df_rat.rename(columns={"message": "msg", "type": "category"})

    ## cppcheck: As we checked, 'msg' and 'verbose' columns have same entries,
    ## so let's keep only 'msg'.
    df_cc = (
        df_cc.drop(columns=["verbose"]) if "verbose" in list(df_cc.columns) else df_cc
    )

    # do this after merging 'suggestion to 'note' column
    if len(df_ff) > 0:
        np_concat = np.vectorize(concat)
        df_ff["note"] = np_concat(df_ff["suggestion"], df_ff["note"])
        df_ff = df_ff.drop(columns=filter_cols)

    df_all = pd.concat([df_ff, df_cc, df_rat]).reset_index(drop=True)

    # print(f"flawfinder cols: {df_ff.columns}\n {len(df_ff)} rows")
    # print(f"cppcheck cols: {df_cc.columns}\n {len(df_cc)} rows")
    # print(f"rats cols: {df_rat.columns}\n {len(df_rat)} rows")
    # print(f"All tools cols: {df_all.columns}\n {len(df_all)} rows")
    return df_all


if __name__ == "__main__":
    chk_dir = "data/projects/contiki-2.4/apps/"
    df_flaw = apply_cppcheck(chk_dir)
    print(df_flaw)
